---
id: YouDonNotKnowJS
title: 《你不知道的 JavaScript》
---

## 第一部分 作用域及闭包

### 1.1 编译原理

1. 传统编译语言编译阶段：分词/词法分析（字符串分解成对编程语言来说有意义的代码块）——> 解析/语法分析（生成抽象语法树 AST）——> 代码生成（AST 转化成可执行代码）![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703404392219-b9d25e8d-c3c7-4c52-95e3-ff9db93f05b1.png)
    1. JavaScript 区别于它们：Javascript 引擎不会有大量的（与其他语言编译器相比）时间用来优化，Javascript 的编译过程并非发生在构建之前，而是在代码执行之前的几微秒内。因此，在本部分所要讨论的作用域背后，Javascript 用了大量的办法来保证性能最佳（比如 JIT,可以延迟编译甚至重编译）。
    2. 原因：其他语言会在编译时有大量时间进行编译，例如 C++，最后会生成一个可执行文件。而 javascript 只会在代码执行前的几微秒内进行实现。

### 1.2 作用域

1. 作用域：作用域由书写代码时函数声明的位置来决定。
2. 作用域、引擎、编译器如何对话：以变量赋值 var a = 2 为例，编译器在当前作用域声明一个变量（此前没声明过），当运行时引擎会去作用域中查找是否存在该变量，若找到则进行赋值。
3. 引擎在作用域中查找变量的三种方式：LHS 查询、RHS 查询、LHS 和 RHS 兼具。  
   简单理解：赋值操作 LHS,取值操作 RHS 1. 当变量出现在左侧时进行 LHS 查询：可理解为“找到赋值操作的目标”，通过找到容器本身来进行赋值。(“a = 2”，此时并不关心 a 的当前值是什么，目的只是想要为=2 找到一个赋值对象) 2. 当变量出现在右侧时进行（更准确为非左侧）RHS 查询：可理解为“retrieve his source value（取得它的源值），即‘谁是赋值操作的源头’”，类似于简单地查找某个变量的值。（“console.log(a)”，此时，对 a 就是 RHS 引用，a 并没有赋予任何值，我们需要去所谓“取得它的源值”来 console.log） 3. 兼具情况：![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703404465724-36da83bf-7363-4c92-88fb-51637c105a55.png) 4. 更详细的 LHS、RHS 介绍，可进入链接查看：[《你不知道的 JavaScript》学习分享](https://www.yuque.com/wanghahaha-g0rsf/neaas2/rfq6wdwhc1o3kk8e)
4. 作用域链：作用域与作用域嵌套形成作用域链，变量的查询从当前作用域开始沿作用域链向全局作用域进行查找。
5. Reference 同作用域判别失败相关；TypeError 为作用域判别成功，但对结果的操作不合理。
6. 词法作用域
    1. 含义：是一套关于引擎如何寻找变量以及会在何处找到变量的规则。
    2. 全局变量可以间接通过对全局对象属性的引用来避开“遮蔽效应(内部标识符'遮蔽'外部标识符)”从而进行访问。（example: window.a）
    3. 修改词法作用域方式：
        1. eval：在运行期间改变词法作用域，生成自己独立的作用域，通常用来执行动态创建的代码。
        2. with（不推荐）  
           两者均存在性能问题，引擎无法在编译时对作用域进行查找优化（以 eval 为例，首先会将 eval 值解析成代码，后再对其进行代码执行,JS 执行两次），且严格模式下不支持。

### 1.3 函数作用域和块作用域

1. 为了让任意代码段“私有”，通常通过作用域来包装（即封装）。
    1. 存在两个问题：
        1. 必须声明一个具名函数，其本身已经污染所在作用域
        2. 须显示调用才能运行其中代码
    2. 解决方案：使用立即执行函数 IIFE![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703404514229-ee90db20-f42b-426a-abd1-7e8dccb94677.png)
        1. `(function foo(){ .. })` 作为函数表达式意味着 foo 只能在 .. 所代表的位置中被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703404525078-f84602d6-e430-4478-95e4-9438fdaca810.png)
2. 具名函数-匿名函数比较
    1. 匿名函数在栈中追踪不会显示有意义的函数名，调试困难
    2. 无函数名在需引用自身时，只能使用过期的 argument.callee
    3. 无函数名可读性差
3. let：该关键字可以将变量绑定到所在的任意作用域中（通常是 `{ .. }` 内部）。let 为其声明的变量隐式地劫持了所在的块作用域。![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703404627741-baa54a0f-e333-470d-bace-9d31247c13ff.png)

### 1.4 提升

1. 函数声明本身会被提升，而包括函数表达式的赋值在内的赋值操作不会。
2. 函数声明优先级>变量声明。
3. JS 引擎会把赋值操作当作两个独立的声明。左侧是编译阶段的任务，右侧是执行阶段的任务。

### 1.5 作用域闭包

1. 简单理解：函数嵌套函数，子函数在外部引用，父函数作用域不被销毁。
2. 具体理解：函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行。
3. 模块函数必备特点：
    1. 必须有外部的封闭函数，该函数必须至少被调用一次（可通过 IIFE 进行首次自调用）。（每次调用都会创建一个新的模块实例）
    2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。
4. 模块函数每次被调用都会创建新的模块实例，可对该模式进行简单的改进来实现单例模式。
5. 现代模块机制：大多数模块依赖加载器/管理器本质上都将这种模块封装进一个友好的 API 中。
    1. 案例：（AMD 规范）![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703404690404-066ff8f3-7d2c-4fd2-9686-edbd43d6c5cf.png)![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703404706316-780e1bb6-2d35-4510-933f-36797f4f1b92.png)
    2. 案例符合 2 中的两个必备特点：调用包装了函数定义的包装函数，并且将返回值作为该模块的 API。
6. es6 和 conmonjs 两种模块的比较：
    1. 共性：都是 js 具有模块化功能的规范
    2. 区别
        1. es6:
            1. export:：可以输出多个，输出方式为 {}
            2. export default：只能输出一个 ，可以 export 同时输出，但是不建议这么做
            3. 解析阶段确定对外输出的接口，解析阶段生成接口
            4. 模块不是对象，加载的不是对象，而是声明式代码的集合
            5. 可以单独加载其中的某个接口（方法）。
            6. 静态分析（[论 ES6 模块系统的静态解析](https://blog.csdn.net/liaozhongping/article/details/68923745)），动态引用，输出的是值的引用，值改变，引用也改变，即原来模块中的值改变则该加载的值也改变
        2. commonJS：
            1. module.exports = ... ：只能输出一个，且后面的会覆盖上面的
            2. exports. ... ：可以输出多个
            3. 运行阶段确定接口，运行时才会加载模块
            4. 模块就是对象，加载的是该对象，纯 JS 系统，就是不依赖其他机制如预处理
            5. 加载的是整个模块，即将所有的接口全部加载进来
            6. 输出的是值的拷贝，即原来模块中的值改变不会影响已经加载的该值

## 第二部分 This 和对象原型

### 2.1 关于 this

1. 核心：
    1. this 是在运行时进行绑定的，而非编写时绑定，它的上下文取决于函数调用时的各种条件。
    2. this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。
    3. this 既不指向函数自身也不指向函数的词法作用域。
    4. this 实际上是在函数“被调用”时发生的绑定，它指向什么完全取决于“函数在哪里被调用”。
2. 以上核心点均强调“调用”，函数调用会生成调用栈，分析函数在调用栈中的真正调用位置，决定了 this 的绑定。（可以借助浏览器的开发者工具通过打断点的方式来查看当前函数的调用栈）
3. 绑定规则：
    1. 默认绑定：
        1. 严格模式下，不能将全局对象用于默认绑定，此时 this 指向 undefined
        2. 非严格模式下，this 指向 window
    2. 隐式绑定：
        1. 示例：![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703404890442-0d8eeb95-ad20-43cd-84b9-0a9e01138fc9.png)
        2. 无论 foo 直接在 obj 中定义还是在全局中定义后再添加为引用属性，这个函数严格来说均不属于 obj。
        3. foo 本与 obj 无关，“obj.foo()”这个写法使得 foo 置于 obj 的上下文中，当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。此时 this.a 等价于 obj.a。
        4. 当出现对象属性引用链时，只有最后一层生效。例如 obj1 和 obj2 中同时拥有 a，obj1.obj2.a，此时的 a 为 obj2 中的 a。
        5. 隐式丢失：被隐式绑定的函数会丢失绑定对象，它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。
    3. 显式绑定：
        1. 方法：通过 call 和 apply 来改变 this 的指向。
        2. 语法：参数一为 this 绑定的对象，区别体现在为枚举还是数组形式。（小 tips：如果参数一为字符串/数字/布尔则会被转换为 new String()/new Number()/new Boolean()形式）
        3. es5 方法：通过 bind，bind 返回一个新函数，会将指定的参数设置为 this 的上下文并调用原始函数。
            1. 硬绑定：通过硬绑定可以解决显式绑定出现的丢失绑定问题。
                1. 示例：![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703404907086-40893b93-b6f7-4e45-9b01-9c0e36696f38.png)
                2. 典型应用场景：创建一个包裹函数，负责接收参数并返回值。
            2. API 上下文：许多函数、方法都提供了可选参数 context，作用和 bind 相同，确保回调函数使用指定的 this。（例如：[].forEach(fn,obj)此时的 obj 为 context）
    4. new 绑定：传统面向类的语言中，“构造函数”是类中的特殊方法，使用 new 初始化类会调用类中的构造函数。而在 JavaScript 中构造函数只是 new 时被调用的函数，并不属于某一个类，也不会实例化一个类。
        1. 绑定过程：
            1. 创建一个全新对象。
            2. 设置原型，将对象原型设置成函数的 prototype 对象。
            3. 新对象绑定到函数调用的 this。
            4. 判断函数返回值类型。（如果是值类型，返回创建的对象，如果是引用类型，返回引用类型的对象）
        2. 对应代码示例：
            1. var obj = new Xxxx();
            2. obj._proto_ = Xxxx.prototype;
            3. var result = Xxxx.call(obj);
            4. return typeof result === 'object' ? result : obj;
4. 绑定优先级：new 绑定 > 显式绑定 > 隐式绑定 > 默认绑定。
5. 软绑定 softBind()：解决硬绑定降低函数灵活性问题，使用硬绑定后无法通过隐式绑定或者显式绑定来修改 this。
6. 简单的 this 判断思路：![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405005847-3e0c6717-90a1-4677-8133-fec05343ea0a.png)
    1. 一些例外情况：当将 null 或者 undefined 作为绑定对象传入 call/apply/bind 时，这些值在调用时会被忽略，仍然使用默认绑定。
7. 箭头函数的 this 在声明时就确定了，会继承外层函数调用的 this 绑定。
8. 有些调用可能无意中使用了默认绑定规则，可以使用 DMZ 对象(demilitarized zone，一个空的非委托对象)来更安全的忽略 this 绑定，var dmzObj = Object.create(null)。相对于{}，使用 Object.create(null)更好，因为它不会创建 Object.prototype 这个委托，比{}“更空”。
9. polyfill：用于旧浏览器的兼容。

### 2.2 对象

1. typeof null 为对象的原理：不同对象在底层都表示为二进制，JavaScript 中二进制前三位均为 0 则会判断为 object 类型，null 的二进制表示全为 0，自然也为 object 类型。
2. 在 Js 引擎内部，对象内部属性值的存储方式多种多样，一般不会存在对象容器内部。存储在对象容器内部的是这些属性的名称，类似指针，指向值的真正存储位置。
3. 在对象中，属性名永远是字符串，即使使用其他值，也会被转化为字符串。
4. 对象的访问方式：
    1. 属性访问：（obj.abc）属性名须符合标识符命名规范。
    2. 键访问：（obj.['abc']）接受 UTF-8/Unicode 字符串。
5. 深拷贝方案：JSON.parse( JSON.stringify( Obj ) )，先转化成 JSON 字符串，再根据其解析出对象。
6. 浅拷贝方案：Object.assign(..)，参数一为目标对象，剩余参数可以是一个或多个源对象。
7. 可计算属性名：ES6 新增，可在文字形式中使用[]来包裹表达式当做属性名。
    1. 示例：![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405058340-6210a4e0-3136-41de-a21b-e54d8a97531f.png)
8. 数组可以通过 “ . ” / “ [ ] ” 语法来添加命名属性，但数组长度不会增加。
    1. 示例：![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405072347-693e2fdc-8aa5-4597-9583-ca71595cab5b.png)
    2. 注：若添加命名看起来像数字，则会被默认转化为下标。
        1. 示例：![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405082902-c8f55500-3b1c-4fb4-8a7f-4974f6aeb950.png)
9. 属性（数据）描述符：可通过 Object.getOwnPropertyDescriptor(obj,prop) 和 Object.defineProperty(obj,prop,description) 来取得给定属性的描述符和定义描述符。
    1. 数据描述符：
        1. value：undefined; 值内容。
        2. writable：true; 是否可写，即修改 value。
        3. configurable：true; 属性是否可配置,即对 writable 和 enumerable 的设置权限，且为 false 还会禁止删除当前属性。（configurable 不可逆，一旦设置 false，不能改回 true）
        4. enumerable：true; 是否可枚举,即能否通过 for..in 返回属性。
    2. 应用：
        1. Object.seal()密封：创建一个“密封”对象（不允许添加、配置、删除任何现有属性），实际是在当前对象调用 object.preventExtensions()并设置所有 configurable:false。（Object.preventExtensions()禁止拓展：禁止对象添加新属性并保留已有属性）
        2. Object.freeze()冻结：创建“冻结”对象（无法修改对象的值），在现有对象上调用 Object.seal() 并设置所有 writable:false。
        3. writable:false + configurable:false 即可创建真正的常量属性。
10. `Get`操作：获取属性值
    1. 示例：![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405101395-beb7f009-981d-47e9-8147-e16b8132a846.png)
    2. 当我们在进行属性访问时，语言规范内部实际上是进行了`Get`操作（等价`Get`()这一函数调用），它会首先在当前对象中先查找 a，若查找不到，则会遍历可能存在的`prototype`链。若依然查找不到，则`Get`操作返回 undefined。
11. `Put`操作：更新属性值
12. Getter 和 Setter 函数可以局限的改写对象默认的`Get`和`Put`操作。
    1. 局限性：只能应用在单个属性上，无法应用在整个对象上。（所以在 vue 框架的响应式实现原理中，新组件创建时，Observer 需要对 data 中每个对象进行逐层递归遍历添加上 Getter 和 Setter，当层级深时会带来较多的时间消耗）
13. 访问描述符：可通过 Object.getOwnPropertyDescriptor(obj,prop) 和 Object.defineProperty(obj,prop,description) 来取得给定属性的描述符和定义描述符。
    1. 访问描述符：
        1. get： 读取属性所调用的函数。
        2. set： 写入属性所调用的函数。
        3. configurable：true;
        4. enumerable：true; 当为 false 时，依然可以通过 obj.xx 语法访问到，但是无法通过 for..in 遍历出来，相当于不可以出现在对象属性的遍历中。
14. 存在性
    1. in 操作符：
        1. 语法："a" in xxx
        2. 含义：会检查属性 a 是否在当前对象及其`prototype`中，返回布尔值。
        3. 注意：当 xxx 为数组时，检查的是'a'这一属性名（key）是否存在，即下标 a 是否存在。
    2. hasOwnProperty(..)：
        1. 语法：xxx.hasOwnProperty('a')
        2. 含义：只检查属性 a 是否存在对象 xxx 中，不找原型链。
    3. propertyIsEnumerable()：
        1. 语法：xxx.propertyIsEnumerable('a')
        2. 含义：'a'是否直接存在于对象 xxx 中，不找原型链。
15. 遍历方式
    1. Object.keys()：返回一个数组，包含所有可枚举属性。
    2. Object.getOwnPropertyNames()：返回一个数组，包含所有属性（可枚举&不可枚举）。
    3. for..in：遍历对象的可枚举属性，包括原型链。
    4. some：一直遍历到 true，一真即返回真，会提前终止遍历。
    5. every：一直遍历到 false，一假即返回假，会提前终止遍历。
    6. forEach：遍历数组所有元素，没有返回。
    7. for..of：遍历的是值而不是数组下标，前提是具有@@iterator 迭代器属性的数据类型，数组具备，有些具备迭代器属性的对象月可以使用。
        1. 内部工作原理：![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405133788-71f818d7-7e92-4728-939c-9452dc10a3a7.png)

### 2.3 混合对象“类”

1. 类是一种设计模式。
2. 混入：其他语言中“类”表现出来的都是复制行为，js 中一个对象并不会复制到其它对象，只会“关联”，js 用“混入”来模拟类的复制行为。
3. JavaScript 和面向类的语言不同，它并没有类来作为对象的抽象模式。JavaScript 中只有对象。

### 2.4 原型

1. 原型链链顶可以认为是 Object.prototype 或者 Object.prototype._proto_=null。
2. 属性设置和屏蔽![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405192552-5896babe-89d9-48f8-be86-0eb2f93566ef.png)
3. 在面向类的语言中，类可以被复制（或者说实例化）多次，但在 JavaScript 中，并没有类似的复制机制，所以不能创建一个类的多个实例，只能创建多个对象，它们 `prototype` 关联的是同一个对象。![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405206273-e7d29f5c-a4bb-4b7a-b22d-db98c6ae5f93.png)
4. constructor 指向当前原型对象的构造函数。
5. isPrototypeOf(..)属性：
    1. 语法：Foo.prototype.isPrototypeOf( a )
    2. 含义：在 a 的整条 Prototype 链中是否出现过 Foo.prototype。
6. getPrototypeOf(..)属性：
    1. 语法：Object.getPrototypeOf( a )
    2. 含义：获取对象 a 的 Prototype 链。
7. setPrototypeOf(..)属性：
    1. 语法：Object.setPrototypeOf( this, o )
    2. 含义：设置对象 的 Prototype 链。
8. *proto*的实现原理：![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405220236-b9f38f31-e482-477c-9d3e-4701c691065d.png)
9. Object.create 的实现原理：![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405231615-392e481b-7689-4ac0-84a6-baaf11c166cd.png)
10. 委托设计模式： 1. 直接委托：  
    ![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405242390-eab35a16-c782-42c5-b853-4b8eecafbc75.png)  
    虽然通过 prototype 也能正确工作，如果目的只是为了在 myObject 上找不到 cool 时，可以使用备用的 anotherObject，则可以换一种写法。 2. 内部委托：![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405254341-9981b7c0-af2f-4805-b091-d252a6817eec.png)

### 2.5 行为委托

1. ES6 的简洁语法的重要缺点：
    1. 示例：![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405275097-cdae8caf-7f06-45cd-9326-6362da33f4cb.png)
    2. 由于函数对象本身没有名称标识符，所以 bar()的缩写形式（function()..）实际上会变成一个匿名函数表达式并赋值给 bar 属性。相比之下，具名函数表达式（function baz()..）会额外给 .baz 属性附加一个词法名称标识符 baz。
    3. 这会牵扯到匿名函数表达式的三个缺陷：
        1. 调用栈难追踪
        2. 自我引用（递归、事件绑定等）
        3. 代码语义化程度降低
    4. 此时，简洁方法比较特殊，它会给对应的函数对象内部设置一个内部的 name 属性，这样可以确保不出现 i、iii 缺陷，然而缺陷 ii 依赖的是自我引用的词法标识符，该方式不具备其。
2. 内省：检查实例类型。
3. 行为委托设计模式：行为委托认为对象之间是兄弟关系，互相委托，而不是父类和子类的关系。JavaScript 的 Prototype 机制本质上就是行为委托机制。
4. 不建议使用”类“：
    1. 在 JavaScript 不存在类。即使是 ES6 的”类“，仍是 prototype 机制的语法糖。
    2. 在 JavaScript 这样的 Prototype 语言中实现类是很别扭的，依赖于 prototype 引用实现的 JavaScript 类内部存在繁琐杂乱的.prototype 引用。
    3. 传统面向类的语言中，子类和父类、子类和实例之间其实均为复制关系。而在 JS 的 prototype 中并没有复制，他们之间只有委托关联。
    4. super 的内部缺陷
        1. 示例：![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405284956-78a6beed-cc9f-4fcd-8925-01b85fcf64b3.png)
        2. 咱们期望 super() 会自动识别出 E 委托了 D，所以 E.foo() 中的 super() 应该调用 D.foo()，然而并不是。super 并不像 this 是动态绑定的，而是静态绑定。

## 第四部分 异步和性能

### 4.1 异步：现在与未来

1. 异步控制台：详见[《你不知道的 JavaScript》学习分享](https://www.yuque.com/wanghahaha-g0rsf/neaas2/rfq6wdwhc1o3kk8e)，文章第二部分。
2. 区别异步和并行：并行线程的交替执行和异步事件的交替粒度完全不同。
    1. 异步：关于现在和将来的时间间隙。（事件循环把自身的工作分成一个个任务并顺序执行，不允许对共享内存进行访问和修改）
    2. 并行：关于能够同事发生的事情。（并行计算最常见的是进程和线程，两者可独立运行，并可能同时运行，多线程可共享同一进程的内存）
3. 并发协作：取一个长期运行的“进程”，对其进行分割成多个任务，使得其他并发“进程”有机会将自己的运算插入到事件循环队列中交替进行。
    1. 场景：请求 1000 万条数据记录，未采用并发协作情况下，需要请求一段时间，在这段时间内页面上其它代码都不能运行，包括其它响应、UI 刷新、滚动、输入、按钮点击事件等，而通过并发协作，异步片段性的批处理这些记录，每次处理运行时间极短，每次处理后返回事件循环，让其它等待事件有机会运行，即使这样意味更多的交替步骤，但对于站点的响应或者说交互体验来说是极大的提升。同时，也是我们处理大数据量的一种解决思路
    2. 非并发协作示例：![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405582437-8ae8effc-3242-4e4d-8f21-81ec14821d7a.png)
    3. 并发协作示例：![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405603435-48c2681d-4a41-4cea-8a06-314834d93398.png)
4. JavaScript 引擎可能会在编译期间于内部对一些语句进行安全的“重新排序”优化来提高执行速度，对于开发者来说，此排序不可见。
    1. 例如代码：![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405610069-ca7eed1d-790b-4b0d-8b7b-7724f054fecd.png)
    2. 可能会在内部重排成：![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405614990-b550135d-ca49-443c-a549-413582a05590.png)
    3. 或者：![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405626076-11cf3319-1f07-41c4-9e20-e8384af81773.png)
    4. 甚至：![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405629342-914ea314-1ac7-4769-ad07-499f9d60935f.png)
5. JavaScript 程序总是至少分为两块：一块现在运行，一块将来运行，以响应某个时间。尽管程序是一块一块执行，但是所有块共享对程序作用域和状态的访问，所以一切对状态的修改都是在之前的累积上所进行的。

### 4.2 回调

1. 回调地狱的真正问题是：一旦指定（即预先计划）了所有的可能事件和路径，代码就会变得非常复杂，以至于无法维护和更新。（嵌套和缩进基本上只是转移注意力的枝节而已）
    1. 示例：![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405649777-1560048a-27d6-4995-9ec8-01383a47a031.png)
    2. 没问题的硬编码情况：把步骤 2、步骤 3 和步骤 4 连接在一起让它们顺序执行，只用回调的话，代价可以接受的唯一方式是把步骤 2 硬编码到步骤 1 中，步骤 3 硬编码到步骤 2 中，步骤 4 硬编码到步骤 3 中，以此类推
    3. 有问题的硬编码情况：硬编码会使代码更脆弱一些，因为它并没有考虑可能导致步骤执行顺序偏离的异常情况。比如，如果步骤 2 失败，就永远不会到达步骤 3，不管是重试步骤 2，还是跳转到其他错误处理流程，等等。这些问题都可以通过在每个步骤中手工硬编码来解决，但这样的代码通常是重复的，并且在程序中的其他异步流中或其他步骤中无法复用
2. 回调会受到控制反转的影响，因为回调暗中把控制权交给第三方（通常是不受你控制的第三方工具！）来调用你代码中的 continuation。这种控制转移导致一系列麻烦的信任问题，比如回调被调用的次数是否会超出预期。
    1. 示例场景：假设你是开发人员，为销售电视的网站建立结账系统，你已经做好了结账系统的各个界面，在最后一页，当用户点击“确定”就可以购买电视时，你需要调用（假设由某个分析追踪公司提供的）第三方函数以便跟踪这个交易，交易完成后展示“谢谢”界面
    2. 示例代码：![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405661139-0741d7e4-5060-4758-a7b1-6b950b4e2515.png)
    3. 可能问题：一个顾客买了一台电视，但是信用卡被刷了 5 次，造成客户愤怒
    4. 原因分析：第三方分析工具函数出于某种原因把你的回调，调用了五次而不是一次
    5. 其它可能出现的问题：
        1. 调用回调过早（追踪之前）
        2. 调用回调过晚（没有调用）
        3. 调用回调次数过多或太少
        4. 没有成功传递环境/参数给回调函数
        5. 吞掉可能出现的错误或异常
        6. ...等等
    6. 总结：由于控制反转，回调并不是可信任或可组合的

### 4.3 Promise

1. 决议：为 Promise 设定最终值/状态。
2. catch(..)等价于 then(null,...)，二者均返回一个新的 Promise。
3. Promise.all([ .. ])：数组中的值可以是 Promise、thenable，甚至是立即值。就本质而言，列表中的每个值都会通过 Promise.resolve(..) 过滤，以确保要等待的是一个真正的 Promise，所以立即值会被规范化为为这个值构建的 Promise。如果数组是空的，主 Promise 就会立即完成。
4. Promise.race([ .. ]) ：数组由一个或多个 Promise、thenable 或立即值组成。立即值之间的竞争在实践中没有太大意义，因为显然列表中的第一个会获胜，一项竞赛需要至少一个“参赛者”。所以，若传入了一个空数组，则该 Promise 永远不会决议，而不是立即决议。（因为 Promise 库早于 ES6 Promise，所以保留了能传入空数组这一问题）
5. Promise 拓展变体：
    1. none([ .. ])：这个模式类似于 all([ .. ])，不过完成和拒绝的情况互换了。所有的 Promise 都要被拒绝，即拒绝转化为完成值，反之亦然
    2. any([ .. ])：这个模式与 all([ .. ]) 类似，但是会忽略拒绝，所以只需要完成一个而不是全部
    3. first([ .. ])：这个模式类似于与 any([ .. ]) 的竞争，即只要第一个 Promise 完成，它就会忽略后续的任何拒绝和完成
    4. last([ .. ])：这个模式类似于 first([ .. ])，但却是只有最后一个完成胜出
        1. 有些 Promise 抽象库对这些变体提供了支持
        2. 也可以通过模仿 all、race 机制进行实现：
            1. first 示例：![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405675251-0b36e4f7-1a39-4027-9d9a-7736924de3a3.png)
6. Promise 错误处理采用分离回调(split-callback)风格，即一个回调用于完成情况，一个回调用于拒绝情况。
    1. 这种设计存在的一个问题：
        1. 错误处理的初衷是为了 Promise 状态能够处理所有的错误，但当 fulfilled 出现错误时，却在函数中无法捕获处理，rejected 方法只是针对 p 的错误处![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703407312600-5b131654-f840-4283-80e3-96527fb1f564.png)
    2. 为了避免丢失被忽略/抛弃的 Promise 错误，目前认为最好的 Promise 链最佳实践是在链尾总以 .catch(handleErrors) 结束![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405694439-c6035bce-ae46-4637-822f-026e894293af.png)
    3. ~~但这种实践依然存在问题，当错误处理函数 handleErrors(...)复杂时，其本身内部也出现错误怎么办？~~
        1. ~~一些社区方案：~~
            1. ~~方案一：一些 Promise 库增加了一些方法，用于注册类似于”全局未处理拒绝“处理函数，这样就不会抛出全局错误，而是调用这个函数。他们辨识未捕获错误的原理是”定义一个某个时长的定时器“，通常为 3 秒，在拒绝的时刻启动。如果 Promise 被拒绝，而在定时器触发之前都没有错误处理函数被注册，它就会假定你不会注册处理函数，进而就是未被捕获错误。实际使用中，这类库运行良好，但在少数情况下，Promise 拒绝和检查拒绝结果之间时延超过 3 秒，这种情况就会误报。~~
            2. ~~方案二：Promise 应该添加一个 done(..)函数，本质上进行标识 Promise 的结束，其不会创建和返回 Promise。~~
    4. 总结：即 Promise 链中的错误很容易被无意中默默忽略掉。如果构建了一个没有错误处理函数的 Promise 链，链中任何地方的任何错误都会在链中一直传播下去，直到被查看（通过在某个步骤注册拒绝处理函数）

### 4.4 生成器

1. 生成器：是一个返回迭代器的函数，是迭代器生成的工具，可以一次或多次启动和停止。
2. 较好的生成器函数声明方式：function *fn(...)，这样在引用时*fn(...)，可以更加明确是引用普通函数还是生成器函数。区别于 function* fn(..)的不同点是*靠近 function 还是 fn。
3. 迭代器：特殊的对象，该对象包含一个 next 方法，每次调用 next 方法后返回一个结果对象，结果对象中包含一个 value 属性和一个 done 属性。
4. next()调用返回一个对象，对象存在两个属性，done：标识迭代器完成状态的布尔值；value：存放迭代值。
5. 如果一个对象原型上具有 Symbol.iterator 属性的实现，那么该对象就可以通过 for...of 进行迭代遍历访问，for..of 循环自动调用对象的 Symbol.iterator 函数来构建迭代器。也可以通过手动调用该函数，并使用其返回的迭代器。![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405707038-0fdda59e-54c9-45e6-810c-4d6b85029e52.png)
6. 具有内置迭代对象的数据类型有 String、Array、Map、Set、类数组。
7. yield/next(..) 这一对不只是一种控制机制，实际上也是一种双向消息传递机制。yield .. 表达式本质上是暂停下来等待某个值，接下来的 next(..) 调用会向被暂停的 yield 表达式传回一个值（或者是隐式的 undefined）。
8. 生成器在异步上的关键优点是：生成器为异步代码保持了顺序、同步、阻塞的代码模式。生成器内部的代码是以自然的同步 / 顺序方式表达任务的一系列步骤。其技巧在于，我们把可能的异步隐藏在了关键字 yield 的后面，把异步移动到控制生成器的迭代器的代码部分。

### 4.5 程序性能

1. Web Worker:![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405713281-8a402e7f-4da1-451e-93b4-b79bd6cfb5bb.png)
2. Web Worker 之间及他们和主程序之间不会共享作用域或资源，而是通过事件消息机制进行通信。
3. Web Worker 对象进行消息接收、发送、终止：onmessage(fn())，postMessage('context..')，terminate()。  
   ![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405734905-e1b78463-8bcb-4088-b469-d1e1a288bf9b.png)
4. Web Worker 的 terminate()：终止 Worker，终止 Worker 线程，则其不会完成当前工作和资源清理，类似于通过关闭浏览器标签页来关闭页面。
5. Web Worker 是完全独立的线程，不能访问主程序任何资源，例如全局变量、页面 DOM 等，但可以执行网络操作（Ajax、WebSockets）以及设定定时器。另外 Worker 可以访问几个重要的全局变量和功能的本地副本，包括 navigator、location、JSON 和 applicationCache。
6. 可以通过 importScripts()方式向 Worker 加载额外的 JavaScript 脚本：importScripts('foo.js','bar.js')，其加载形式为同步。
7. Web Worker 应用场景：密集型数学计算、大数据集排序、数据处理（压缩、音频分析、图像处理等）、高流量网络通信。
8. Web Worker 数据传递：这些应用存在一个共性就是需要在线程之间通过事件机制传递消息，可能是双向的。
    1. 早期：把所有数据序列化到字符串中。（存在问题：双向序列化导致的速度损失、数据需要复制损耗双倍内存及其垃圾回收消耗）
    2. 当前：
        1. 方式一：使用[结构化克隆算法](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Structured_clone_algorithm)，传递对象的情况，可处理复制对象内有循环引用的情况，不用付出 to-string 和 from-string 的性能损失，此方式仍然需要付出双倍内存；
        2. 方式二(更优)：使用[Transferable 对象](https://developer.mozilla.org/zh-CN/docs/Web/API/Transferable)，改变数据所有权，数据本身不发生移动，在所有权改变到另一 Worker 上时，原位置上变为空或不可访问，消除多线程编程作用域共享带来的混乱。
9. [共享 Worker](https://developer.mozilla.org/zh-CN/docs/Web/API/SharedWorker)：应用允许加载同一页面的多个 Tab，防止 Worker 的复用降低系统的资源使用，如 socket 网络连接。
10. [SIMD 单指令多数据](https://www.bilibili.com/video/av374387840/)：数据并行方式，区别于 Web Worker 的任务并行，Worker 是把程序逻辑分成并行的块，而 SIMD 是并行处理数据的多个位。
11. SIMD 方式：通过 SIMD，线程不再提供并行。取而代之的是，现代 CPU 通过数字“向量”（特定类型的数组），以及可以在所有这些数字上并行操作的指令，来提供 SIMD 功能。
12. SIMD 理解：对数组 a 和 b 的对应成员进行相加。
    1. 正常情况下，需要四次运算：![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405747487-a965684a-8acd-43d3-88a0-cf457ddc394f.png)
    2. 采用 SMID 模式，则只需一次运算：![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405761312-70d57707-886e-4793-8885-4820d3f61387.png)
13. SIMD 应用场景：3D 动画、图像处理、信号处理、数值处理、加密等矢量运算密集型场景。`v + w = <v1,v2,...,vn> + <w1,w2,...,wn> = <v1+w1,v2+w2,...,vn+wn>`
14. SIMD in JS 未来：目前在[WebAssembly](https://www.wasm.com.cn/)中处于积极发展中，Chrome 91 支持 WebAssembly SIMD，其有机会让 JS 达到二进制代码的运行速度。

### 4.6 类型转换

![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405767695-7b3b0edf-542f-4b8e-a783-c2472d415fe6.png)

1. 类型转换：
    1. 布尔值为假：“”（空字符串），0，-0，NaN，null，undefined，false；
    2. 布尔值为真：[]，{}，function fn(){}，true，123，'123'等。
2. 比较运算：当比较运算符两侧均为字符串时，依照字典顺序进行比较；如果其中一边或两边均不是字符串，则两个值的类型都转化为数字进行比较。（当其中一个值无法转化为有效数字时，会成 NaN，比较结果永远为 false）
    1. 示例：![](https://cdn.nlark.com/yuque/0/2023/png/25855170/1703405777149-e50fa519-4e54-43b5-a74b-85302465c57e.png)
3. 对象和布尔值比较：对象=>字符串=>数字，布尔值=>数字。
    1. [] == true; // false
    2. 过程：[]转换为字符串''，然后转换为数字 0，true 转换为数字 1，所以为 false 。
4. 对象和字符串：对象=>字符串。
    1. [1,2,3] == '1,2,3'；
    2. 过程：true [1,2,3]转化为'1,2,3'，然后和'1,2,3'， 所以结果为 true。
5. 对象和数字：对象=>字符串=>数字。
6. 字符串和数字：字符串=>数字。
7. 字符串和布尔值：二者均=>数值。
8. 布尔值和数字：布尔=>数字。
9. 除 0、NaN、null、""、undefined 以外的使用“！”，都会将该类型转换为 false，再取反，最终为 true。
