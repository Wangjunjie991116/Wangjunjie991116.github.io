## Hooks

1. 不要过度依赖 useMemo
    1. **`useMemo` 本身也有开销**  
       `useMemo` 会「记住」一些值，同时在后续 `render` 时，将依赖数组中的值取出来和上一次记录的值进行比较，如果不相等才会重新执行回调函数，否则直接返回「记住」的值。这个过程本身就会消耗一定的内存和计算资源
    2. **在使用 `useMemo` 前，应该考虑三个问题**
        1. **传递给 `useMemo` 的函数开销大不大？**  
           有些计算开销很大，我们就需要「记住」它的返回值，避免每次 `render` 都去重新计算。如果你执行的操作开销不大，那么就不需要记住返回值。否则，使用`useMemo`本身的开销就可能超过重新计算这个值的开销。因此，对于一些简单的 JS 运算来说，我们不需要使用`useMemo`来「记住」它的返回值
        2. **返回的值是原始值吗？**  
           如果计算出来的是基本类型的值（`string`、`boolean`、`null`、`undefined`、`number`、`symbol`），那么每次比较都是相等的，下游组件就不会重新渲染；如果计算出来的是复杂类型的值（`object`、`array`），哪怕值不变，但是地址会发生变化，导致下游组件重新渲染。所以我们也需要「记住」这个值
        3. **在编写自定义 Hook 时，返回值一定要保持引用的一致性。**  
           因为你无法确定外部要如何使用它的返回值。如果返回值被用做其他 Hook 的依赖，并且每次 `re-render` 时引用不一致（当值相等的情況），就可能会产生 Bug。所以如果自定义 Hook 中暴露出来的值是 `object`、`array`、函数等，都应该使用 `useMemo`。以确保当值相同时，引用不发生变化
